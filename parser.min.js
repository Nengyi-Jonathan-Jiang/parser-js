const {
    Lexer,
    LRParser,
    Token,
    JSymbol,
    ParsingTable,
    LR1ParseTableBuilder,
    fetchTextContents,
    createLexerFromFile,
    createParserFromFile
} = (() => {
    class FMap {
        #a;
        #b;

        constructor(t, e = []) {
            this.#b = t, this.#a = new Map([...e].map(([e, s]) => [t(e), [e, s]]))
        }

        get size() {
            return this.#a.size
        }

        [Symbol.iterator]() {
            return this.#a.values()[Symbol.iterator]()
        }

        clear() {
            this.#a.clear()
        }

        delete(t) {
            return this.#a.delete(this.#b(t))
        }

        entries() {
            return this.#a.values()
        }

        forEach(t, e) {
            [...this.#a.entries()].forEach(([s, r]) => {
                t.call(e, s, r, this)
            })
        }

        get(t) {
            return this.#a.get(this.#b(t))?.[1]
        }

        has(t) {
            return this.#a.has(this.#b(t))
        }

        keys() {
            return [...this.#a.values()].map(t => t[0])[Symbol.iterator]()
        }

        set(t, e) {
            return this.#a.set(this.#b(t), [t, e]), this
        }

        values() {
            return [...this.#a.values()].map(t => t[1])[Symbol.iterator]()
        }
    }

    class FSet {
        #a;
        #b;

        constructor(t, e = []) {
            this.#b = t, this.#a = new Map([...e].map(e => [t(e), e]))
        }

        get size() {
            return this.#a.size
        }

        [Symbol.iterator]() {
            return this.#a.values()[Symbol.iterator]()
        }

        clear() {
            this.#a.clear()
        }

        add(t) {
            this.#a.set(this.#b(t), t)
        }

        delete(t) {
            return this.#a.delete(this.#b(t))
        }

        entries() {
            return this.#a.values()
        }

        forEach(t, e) {
            [...this.#a.values()].forEach(s => {
                t.call(e, s, s, this)
            })
        }

        has(t) {
            return this.#a.has(this.#b(t))
        }

        keys() {
            return [...this.#a.values()].map(t => t[0])[Symbol.iterator]()
        }

        values() {
            return [...this.#a.values()].map(t => t[1])[Symbol.iterator]()
        }
    }

    class SMap extends FMap {
        constructor(t = []) {
            super(t => t.toString(), t)
        }
    }

    class SSet extends FSet {
        constructor(t = []) {
            super(t => t.toString(), t)
        }
    }

    class JSymbol {
        static #a = new Map;
        static #c = 0;
        #d;
        #e;

        constructor(t) {
            this.#d = t, this.#e = JSymbol.#c++
        }

        get name() {
            return this.#d
        }

        get id() {
            return this.#e
        }

        static get(t) {
            let e = this.#a;
            return e.has(t) || e.set(t, new JSymbol(t)), e.get(t)
        }

        toString() {
            return this.#d
        }

        static __EPSILON__ = JSymbol.get("\x01EPSILON\x01");
        static __START__ = JSymbol.get("\x01START\x01");
        static __EOF__ = JSymbol.get("\x01END\x01")
    }

    class Token {
        #f;
        #g;
        #h;
        #i;

        constructor(t, e, s, r) {
            this.#f = t, this.#i = e, this.#g = s, this.#h = r
        }

        get type() {
            return this.#f
        }

        get startIndex() {
            return this.#g
        }

        get endIndex() {
            return this.#h
        }

        get value() {
            return this.#i
        }

        toString() {
            let {type: t, value: e} = this;
            return t === JSymbol.__START__ ? "__START__" : t === JSymbol.__EOF__ ? "__EOF___" : t === JSymbol.__EPSILON__ ? "__EPSILON__" : t.name === e ? t.name : `${t}<${e}>`
        }
    }

    class AbstractSyntaxTree {
        #j;
        #k;

        constructor(t, ...e) {
            this.#j = t, this.#k = e
        }

        get type() {
            return this.#j
        }

        get children() {
            return this.#k
        }

        [Symbol.iterator]() {
            return this.#k[Symbol.iterator]()
        }
    }

    const FSM_ERROR_STATE = Number.POSITIVE_INFINITY, DFA_INITIAL_STATE = 0,
        ALL_CHARS = new Set("\n	 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"),
        WORD_CHARS = new Set("ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz0123456789"),
        LETTER_CHARS = new Set("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"),
        DIGIT_CHARS = new Set("0123456789"), SPACE_CHARS = new Set("\n	 ");

    class DFA {
        #l = new Map;
        #m = new Map;

        get transitionTable() {
            return this.#l
        }

        get acceptingStates() {
            return this.#m
        }

        getEntryForState(t) {
            return this.#l.has(t) || this.#l.set(t, new Map), this.#l.get(t)
        }

        on(t, e) {
            return this.getEntryForState(t).get(e)
        }

        addTransition(t, e, s) {
            if (1 !== e.length) throw Error("DFA can only transition on single characters, not strings");
            let r = this.getEntryForState(t);
            if (r.has(e)) throw Error("Cannot have multiple transitions in DFA");
            return r.set(e, s), this
        }

        clone() {
            let t = new DFA;
            for (let [e, s] of this.#l.entries()) t.#l.set(e, new Map(s));
            return t.#m = new Map(this.#m), t
        }

        toString() {
            return `${printTable(this.transitionTable)}\naccepts {${[...this.acceptingStates.entries()].map(([t, e]) => `${t} -> ${e}`).join(", ")}}`
        }
    }

    class NFA {
        static get INITIAL_STATE() {
            return 0
        }

        static get FINAL_STATE() {
            return -1
        }

        #l = new Map;
        static EPSILON = "ε";

        getEntryForState(t) {
            return this.#l.has(t) || this.#l.set(t, new Map), this.#l.get(t)
        }

        getTransitionsOnChar(t, e) {
            let s = this.getEntryForState(t);
            return s.has(e) || s.set(e, new Set), s.get(e)
        }

        get transitionTable() {
            return this.#l
        }

        addTransition(t, e, s) {
            if (t === NFA.FINAL_STATE) throw Error("Cannot have transition from final state in NFA");
            if (1 !== e.length) throw Error("NFA can only transition on single characters, not strings");
            let r = this.getTransitionsOnChar(t, e);
            if (r.size) throw Error("Cannot have multiple non-epsilon transition in NFA");
            return r.add(s), this
        }

        addEpsilonTransition(t, ...e) {
            if (t === NFA.FINAL_STATE) throw Error("Cannot have transition from final state in NFA");
            let s = this.getTransitionsOnChar(t, NFA.EPSILON);
            return e.forEach(t => s.add(t)), this
        }

        mergeWith(t) {
            return this.#l = new Map([...this.transitionTable, ...t.transitionTable]), this
        }

        remap(t, e) {
            if (!this.#l.size) return this;
            let s = this.#l;
            for (let r of s.values()) for (let i of r.values()) i.has(NFA.INITIAL_STATE) && (i.delete(NFA.INITIAL_STATE), i.add(t)), i.has(NFA.FINAL_STATE) && (i.delete(NFA.FINAL_STATE), i.add(e));
            let n = s.get(NFA.INITIAL_STATE);
            return s.delete(NFA.INITIAL_STATE), s.set(t, n), this
        }

        remapped(t, e) {
            return this.clone().remap(t, e)
        }

        static #n = 1;

        static getNextUnusedState() {
            return this.#n++
        }

        clone() {
            let t = new NFA;
            for (let [e, s] of this.#l.entries()) t.#l.set(e, new Map(s));
            return t
        }

        static get trivialNFA() {
            let t = new NFA;
            return t.addEpsilonTransition(NFA.INITIAL_STATE, NFA.FINAL_STATE), t
        }
    }

    function createDFAStateInfo(t, e) {
        return `${t.toSorted().join(",")}\x02${e?.name ?? ""}`
    }

    function getDFAStateInfo(t) {
        let [e, s] = t.split('\x02');
        return {states: e.split(",").map(t => +t), symbol: s ? JSymbol.get(s) : null}
    }

    class MultiAcceptNFA extends NFA {
        acceptingStates = new Map;
        statePriority = new Map;

        constructor() {
            super()
        }

        toString() {
            return `${super.toString()}\naccepts {${[...this.acceptingStates.entries()].map(([t, e]) => `${t} -> ${e}`).join(", ")}}`
        }
    }

    function compute_closure(t, e, s = !1) {
        let r = new Set(t);
        for (; r.size;) {
            let i = r.values().next().value;
            for (let n of (r.delete(i), e(i))) s ? r.add(n) : t.has(n) || (t.add(n), r.add(n))
        }
        return t
    }

    class NFA2DFA {
        #o;
        #p = 1;
        #q = new Map;
        #r = new Map;
        #s = new Set;

        constructor(t) {
            this.#o = t
        }

        epsilonClosure(t) {
            let e = new Set(t), s = null, r = Number.POSITIVE_INFINITY;
            return compute_closure(e, t => {
                let e = this.#o.acceptingStates.get(t), i = this.#o.statePriority.get(t);
                e && i < r && (s = e, r = i);
                let n = this.#o.getEntryForState(t);
                return n.get(NFA.EPSILON) ?? new Set
            }), createDFAStateInfo([...e], s)
        }

        convert() {
            let t = new DFA, e = this.epsilonClosure(new Set([0]));
            return this.#q.set(0, e), this.#r.set(e, 0), compute_closure(new Set([0]), e => {
                let s = new Map;
                for (let r of getDFAStateInfo(this.#q.get(e)).states) for (let [i, n] of this.#o.getEntryForState(r)) i !== NFA.EPSILON && (s.has(i) || s.set(i, new Set), n.forEach(t => s.get(i).add(t)));
                let a = new Set;
                for (let [o, l] of s) {
                    let h = this.epsilonClosure(l);
                    if (this.#s.has(h)) {
                        t.addTransition(e, o, this.#r.get(h));
                        continue
                    }
                    this.#s.add(h);
                    let c = this.#p++;
                    a.add(c), this.#q.set(c, h), this.#r.set(h, c), t.addTransition(e, o, c);
                    let u = getDFAStateInfo(h).symbol;
                    null !== u && t.acceptingStates.set(c, u)
                }
                return a
            }, !0), t
        }
    }

    function remap_states(t, e) {
        let s = e[0]++, r = e[0]++, i = new Map([[NFA.INITIAL_STATE, s], [NFA.FINAL_STATE, r]]);
        for (let [n, a] of t) for (let [, o] of (i.has(n) || i.set(n, e[0]++), a)) for (let l of o) i.has(l) || i.set(l, e[0]++);
        let h = new Map([[r, new Map]]);
        for (let [c, u] of t) {
            let g = new Map;
            for (let [d, p] of u) {
                let S = new Set;
                for (let f of p) S.add(i.get(f));
                g.set(d, S)
            }
            h.set(i.get(c), g)
        }
        return {new_table: h, mapped_start: s, mapped_end: r}
    }

    function compileToDFA(...t) {
        let e = new MultiAcceptNFA, s = [1];
        for (let r = 0; r < t.length; r++) {
            let {nfa: i, symbol: n} = t[r], {
                new_table: a, mapped_start: o, mapped_end: l
            } = remap_states(i.transitionTable, s);
            e.mergeWith({transitionTable: a}), e.addEpsilonTransition(0, o), e.acceptingStates.set(l, n), e.statePriority.set(l, r)
        }
        return new NFA2DFA(e).convert()
    }

    class Regex {
        #k = [];

        constructor(...t) {
            this.#k = t
        }

        get childNodes() {
            return this.#k
        }

        addChild(t) {
            return this.#k.push(t), this
        }

        compileChildren() {
            return this.childNodes.map(t => t.compile())
        }

        compile() {
        }

        static parse = parseRegex;

        toString() {
            return JSON.stringify(this.toJSON(), null, 2)
        }

        toJSON() {
            return {name: this.constructor.name, ...this.childNodes.length ? {children: this.childNodes.map(t => t.toJSON())} : {}}
        }
    }

    class LeafNode extends Regex {
        #t;

        constructor(t) {
            super(), this.#t = t
        }

        compile() {
            let t = new NFA;
            for (let e of this.#t) t.addTransition(NFA.INITIAL_STATE, e, NFA.FINAL_STATE);
            return t
        }

        toJSON() {
            return [...this.#t]
        }
    }

    class AlternationNode extends Regex {
        constructor(...t) {
            super(...t)
        }

        compile() {
            let t = new NFA;
            for (let e of this.compileChildren()) {
                let s = NFA.getNextUnusedState();
                t.mergeWith(e.remap(s, NFA.FINAL_STATE)).addEpsilonTransition(NFA.INITIAL_STATE, s)
            }
            return t
        }
    }

    class ConcatenationNode extends Regex {
        constructor(...t) {
            super(...t)
        }

        compile() {
            if (0 === this.childNodes.length) return NFA.trivialNFA;
            let [t, ...e] = this.compileChildren(), s = t;
            for (let r of e) {
                let i = NFA.getNextUnusedState();
                s.remap(NFA.INITIAL_STATE, i).mergeWith(r.remapped(i, NFA.FINAL_STATE))
            }
            return s
        }
    }

    class OptionalNode extends Regex {
        constructor(t) {
            super(t)
        }

        compile() {
            let [t] = this.compileChildren();
            return t.addEpsilonTransition(NFA.INITIAL_STATE, NFA.FINAL_STATE)
        }

        addChild(t) {
            throw Error("Optional regex node can only have one child")
        }
    }

    class KleeneStarNode extends Regex {
        constructor(t) {
            super(t)
        }

        compile() {
            let [t] = this.compileChildren(), e = NFA.getNextUnusedState();
            return t.remap(NFA.INITIAL_STATE, e).addEpsilonTransition(NFA.INITIAL_STATE, e).addEpsilonTransition(e, NFA.INITIAL_STATE, NFA.FINAL_STATE)
        }

        addChild(t) {
            throw Error("Kleene star regex node can only have one child")
        }
    }

    class KleenePlusNode extends Regex {
        constructor(t) {
            super(t)
        }

        compile() {
            let [t] = this.compileChildren(), e = NFA.getNextUnusedState();
            return t.remap(NFA.INITIAL_STATE, e).addEpsilonTransition(e, NFA.INITIAL_STATE, NFA.FINAL_STATE)
        }

        addChild(t) {
            throw Error("Kleene plus regex node can only have one child")
        }
    }

    class RegexParser {
        #u = [];
        #v = [];

        get hasOperatorsLeft() {
            return !!this.#u.length
        }

        chars(t) {
            this.#u.push(new LeafNode(t))
        }

        concat() {
            for (; this.hasOperatorsLeft && "STRING" === this.#v[this.#v.length - 1];) {
                let t = this.#u.pop(), e = this.#u.pop();
                this.#v.pop(), this.#u.push(e.addChild(t))
            }
            this.#v.push("STRING")
        }

        alternation() {
            for (; this.hasOperatorsLeft && "PAREN" !== this.#v[this.#v.length - 1];) {
                let t = this.#u.pop(), e = this.#u.pop();
                switch (this.#v.pop()) {
                    case"ALTERNATION":
                        if (!(e instanceof AlternationNode)) {
                            this.#u.push(new AlternationNode(e, t));
                            break
                        }
                    case"STRING":
                        this.#u.push(e.addChild(t));
                        break;
                    default:
                        throw Error("Something went wrong :(")
                }
            }
            this.#v.push("ALTERNATION"), this.#u.push(new ConcatenationNode)
        }

        begin_group() {
            this.#v.push("PAREN"), this.#u.push(new ConcatenationNode)
        }

        end_group() {
            for (let t; "PAREN" !== (t = this.#v.pop());) {
                let e = this.#u.pop(), s = this.#u.pop();
                switch (t) {
                    case"ALTERNATION":
                        if (!(s instanceof AlternationNode)) {
                            this.#u.push(new AlternationNode(s, e));
                            break
                        }
                    case"STRING":
                        this.#u.push(s.addChild(e));
                        break;
                    default:
                        throw Error("Something went wrong :(")
                }
            }
        }

        apply(t) {
            this.#u.push(new t(this.#u.pop()))
        }

        get result() {
            return this.#u[0]
        }
    }

    function charsForEscape(t) {
        switch (t) {
            case"w":
                return [...WORD_CHARS];
            case"l":
                return [...LETTER_CHARS];
            case"d":
                return [...DIGIT_CHARS];
            case"s":
                return [...SPACE_CHARS];
            case"n":
                return ["\n"];
            case"t":
                return ["	"];
            default:
                return [t]
        }
    }

    function parseRegex(t) {
        let e = new RegexParser;
        e.begin_group();
        for (let s = 0; s < t.length; s++) {
            let r = t[s];
            switch (r) {
                case"|":
                    e.alternation();
                    break;
                case"(":
                    e.concat(), e.begin_group();
                    break;
                case")":
                    e.end_group();
                    break;
                case"+":
                    e.apply(KleenePlusNode);
                    break;
                case"*":
                    e.apply(KleeneStarNode);
                    break;
                case"?":
                    e.apply(OptionalNode);
                    break;
                case".":
                    e.concat(), e.chars(ALL_CHARS);
                    break;
                case"[":
                    let i = !1, n = new Set;
                    for ("^" === t[s + 1] && (i = !0, n = new Set(ALL_CHARS), s++); s < t.length && "]" !== (r = t[++s]);) {
                        let a = "\\" === r ? charsForEscape(t[++s]) : [r];
                        for (let o of a) i ? n.delete(o) : n.add(o)
                    }
                    if (0 === n.size) throw Error("Error parsing regex: empty character class");
                    e.concat(), e.chars(n);
                    break;
                case"]":
                    throw Error("Error parsing regex: mismatched brackets []");
                case"\\":
                    e.concat(), e.chars(new Set(charsForEscape(t[++s])));
                    break;
                default:
                    e.concat(), e.chars(new Set(r))
            }
        }
        return e.end_group(), e.result
    }

    class Lexer {
        #w;
        #x;

        constructor(t, e) {
            this.#w = t, this.#x = new Set(e)
        }

        lex(t) {
            let e = new Lex(this.#w, t, this.#x), s = [];
            for (; ;) {
                let r = e.next();
                if (s.push(r), r.type === JSymbol.__EOF__) break
            }
            return s
        }
    }

    class Lex {
        #w;
        #y;
        #x;
        #z = 0;
        #A = !1;

        constructor(t, e, s) {
            this.#x = s, this.#w = t, this.#y = e
        }

        get done() {
            return this.#z === this.#y.length
        }

        try_get_next() {
            if (this.done) return new Token(JSymbol.__EOF__, "", this.#z, this.#z);
            let t = null, e = this.#z, s = this.#z, r = 0;
            for (; r !== FSM_ERROR_STATE && this.#z < this.#y.length;) {
                let i = this.#w.on(r, this.#y[this.#z++]);
                this.#w.acceptingStates.has(i) && (t = this.#w.acceptingStates.get(i), s = this.#z), r = i
            }
            return null === t ? (this.#z = e + 1, null) : (this.#z = s, this.#x.has(t)) ? null : new Token(t, this.#y.substring(e, s), e, s)
        }

        next() {
            for (; ;) {
                let t = this.try_get_next();
                if (null !== t) return t
            }
        }
    }

    function addAll(t, e) {
        let s = !1;
        for (let r of e) t.has(r) || (s = !0, t.add(r));
        return s
    }

    class Grammar {
        #B;
        #C;
        #D = new Map;
        #E = new Set;
        #F = new Set;
        #G = new Set;
        #H = new Set;
        #I = new Map;
        #J = new Map;
        #K = new SMap;
        #L = new SMap;

        constructor(t, e) {
            for (let s of (this.#B = t, this.#C = new Rule(JSymbol.__START__, new SymbolString(e), !1, !0), this.#B.push(this.#C), this.#E.add(JSymbol.__START__), this.#E.add(JSymbol.__EOF__), this.#G.add(JSymbol.__START__), this.#B)) this.#G.add(s.lhs), this.#E.add(s.lhs), addAll(this.#E, s.rhs);
            for (let r of (this.#F = new Set(this.#E), this.#G.forEach(t => this.#F.delete(t)), this.#E)) this.#D.set(r, []);
            for (let i of this.#B) this.#D.get(i.lhs).push(i);
            for (let n of this.#E) this.#I.set(n, new SymbolSet), this.#J.set(n, new SymbolSet), this.#F.has(n) && this.#I.get(n).add(n);
            this.#J.get(JSymbol.__START__).add(JSymbol.__EOF__);
            let a = !0;
            for (; a;) for (let o of (a = !1, this.#B)) {
                let {lhs: l, rhs: h} = o, c = !1;
                for (let u of h) if (a |= addAll(this.#I.get(l), this.first(u)), !this.isNullable(u)) {
                    c = !0;
                    break
                }
                c || this.isNullable(l) || (this.#H.add(l), a = !0);
                let g = this.follow(l);
                for (let d = h.size - 1; d >= 0; d--) this.#G.has(h.get(d)) && (a |= addAll(this.#J.get(h.get(d)), g)), this.isNullable(h.get(d)) ? addAll(g = new Set(g), this.first(h.get(d))) : g = this.first(h.get(d))
            }
        }

        get rules() {
            return this.#B
        }

        getRules(t) {
            return this.#D.get(t)
        }

        get allSymbols() {
            return this.#E
        }

        get nonTerminals() {
            return this.#G
        }

        get terminals() {
            return this.#F
        }

        get startRule() {
            return this.#C
        }

        toString() {
            return this.rules.join("\n")
        }

        isNullable(t) {
            if (t instanceof JSymbol) return this.#H.has(t);
            if (0 === t.size) return !0;
            for (let e of t) if (!this.isNullable(e)) return !1;
            return !0
        }

        follow(t) {
            if (t instanceof JSymbol) return this.#J.get(t);
            if (0 === t.size) return new Set([JSymbol.__EPSILON__]);
            if (this.#L.has(t)) return this.#L.get(t);
            let e = new Set(this.follow(t.lastTkn));
            return this.#H.has(t.lastTkn) && addAll(e, this.follow(t.substring(0, t.size - 1))), this.#L.set(t, e), e
        }

        first(t) {
            if (t instanceof JSymbol) return this.#I.get(t);
            if (0 === t.size) return new Set([JSymbol.__EPSILON__]);
            if (this.#K.has(t)) return this.#K.get(t);
            let e = new Set(this.first(t.firstTkn));
            return this.#H.has(t.firstTkn) && addAll(e, this.first(t.substring(1))), this.#K.set(t, e), e
        }
    }

    class LRParser {
        #M;

        constructor(t) {
            this.#M = t
        }

        get table() {
            return this.#M
        }

        parseTokens(t) {
            let e = this.startParse();
            for (let s of t) e.process(s);
            if (!e.isFinished) throw Error("Invalid parse");
            return e.result
        }

        startParse() {
            return new LRParse(this.#M)
        }
    }

    class LRParse {
        #N = [0];
        #O = [];
        #M;
        #P = !1;

        constructor(t) {
            this.#M = t
        }

        get result() {
            return this.#O[0]
        }

        get isFinished() {
            return this.#P
        }

        process(t) {
            for (; ;) {
                let e = this.#N[this.#N.length - 1], s = this.#M.getAction(e, t.type);
                if (null == s) throw Error(`Parse failed: expected one of ${[...this.#M.acceptableSymbolsAtState(e)].join(", ")}, instead got ${t}`);
                if (s instanceof ShiftEntry) {
                    this.#N.push(s.nextState), this.#O.push(t);
                    return
                }
                if (s instanceof AcceptEntry) {
                    this.#P = !0;
                    return
                }
                if (s instanceof ReduceEntry) {
                    let r = s.rule, i = r.lhs;
                    for (let n = 0; n < r.rhs.size; n++) this.#N.pop();
                    let a = this.#M.getGoto(this.#N[this.#N.length - 1], i);
                    if (this.#N.push(a.nextState), 1 === r.rhs.size && r.unwrap) continue;
                    let o = Array(r.rhs.size);
                    for (let l = r.rhs.size - 1; l >= 0; l--) o[l] = this.#O.pop();
                    if (r.chained) {
                        let h = o[0];
                        if (h.type === i) {
                            let c = [...h.children, ...o.toSpliced(0, 1)];
                            this.#O.push(new AbstractSyntaxTree(i, ...c));
                            continue
                        }
                    }
                    this.#O.push(new AbstractSyntaxTree(i, ...o))
                } else throw Error("Something went wrong :(")
            }
        }
    }

    class ParsingTable {
        #M;
        #Q;
        #R = [];

        constructor(t) {
            this.#Q = t, this.#M = Array(t).fill(null).map(t => new Map)
        }

        getAction(t, e) {
            return this.#M[t].get(e)
        }

        acceptableSymbolsAtState(t) {
            return new Set(this.#M[t].keys())
        }

        getGoto(t, e) {
            return this.#M[t].get(e)
        }

        setActionReduce(t, e, s) {
            let r = this.#M[t].get(e);
            r instanceof ShiftEntry ? this.#R.push({
                type: "SR", state: t, symbol: e, nextState: r.nextState, rule: s
            }) : r instanceof ReduceEntry ? s !== r.rule && this.#R.push({
                type: "RR", state: t, symbol: e, rule1: s, rule2: r.rule
            }) : void 0 !== r && (console.log(r), this.#R.push({type: "Unknown"})), this.#M[t].set(e, new ReduceEntry(s))
        }

        setActionShift(t, e, s) {
            let r = this.#M[t].get(e);
            r instanceof ReduceEntry ? this.#R.push({
                type: "SR", state: t, symbol: e, nextState: s, rule: r.rule
            }) : r instanceof ShiftEntry ? s !== r.nextState && this.#R.push({type: "SS"}) : void 0 !== r && this.#R.push({type: "Unknown"}), this.#M[t].set(e, new ShiftEntry(s))
        }

        setActionAccept(t, e) {
            this.#M[t].set(e, new AcceptEntry)
        }

        setGoto(t, e, s) {
            this.#M[t].set(e, new GotoEntry(s))
        }

        get conflicts() {
            return this.#R
        }

        toString() {
            let t = "", e = this.#M.length;
            for (let s of (t += e + "\n", this.#M)) for (let [r, i] of (t += `state ${s.size}\n`, s)) i instanceof ShiftEntry ? t += `${r} shift ${i.nextState}\n` : i instanceof ReduceEntry ? t += `${r} reduce ${i.rule}\n` : i instanceof AcceptEntry ? t += `${r} accept\n` : i instanceof GotoEntry && (t += `${r} goto ${i.nextState}\n`);
            return t
        }

        static fromString(t) {
            let e = t.split(/\s*\n\s*/g), s = 0, r = new Map, i = +e[s++], n = new ParsingTable(i);
            for (let a = 0; a < i; a++) for (let o = +e[s++].split(" ")[1]; o-- > 0;) {
                let l = e[s++], [h, c, ...u] = l.split(" ");
                switch (h = JSymbol.get(h), c) {
                    case"shift":
                        n.setActionShift(a, h, +u[0]);
                        break;
                    case"reduce":
                        let g = u.join(" ");
                        if (!r.has(g)) {
                            let d = !0, p = !1;
                            "__WRAP__" === u[0] ? (d = !1, u.shift()) : "__CHAIN__" === u[0] && (p = !0, u.shift());
                            let [S, , ...f] = u.map(t => JSymbol.get(t.trim())),
                                m = new Rule(S, new SymbolString(...f), p, d);
                            r.set(g, m)
                        }
                        n.setActionReduce(a, h, r.get(g));
                        break;
                    case"accept":
                        n.setActionAccept(a, h);
                        break;
                    case"goto":
                        n.setGoto(a, h, +u[0])
                }
            }
            return n
        }
    }

    class TableEntry {
        static EntryType = {SHIFT: "SHIFT", REDUCE: "REDUCE", ACCEPT: "ACCEPT", GOTO: "GOTO"};

        get actionType() {
        }
    }

    class ReduceEntry extends TableEntry {
        #S;

        constructor(t) {
            super(), this.#S = t
        }

        get actionType() {
            return TableEntry.EntryType.REDUCE
        }

        get rule() {
            return this.#S
        }
    }

    class ShiftEntry extends TableEntry {
        #p;

        constructor(t) {
            super(), this.#p = t
        }

        get actionType() {
            return TableEntry.EntryType.SHIFT
        }

        get nextState() {
            return this.#p
        }
    }

    class AcceptEntry extends TableEntry {
        get actionType() {
            return TableEntry.EntryType.ACCEPT
        }
    }

    class GotoEntry extends TableEntry {
        #p;

        constructor(t) {
            super(), this.#p = t
        }

        get actionType() {
            return TableEntry.EntryType.GOTO
        }

        get nextState() {
            return this.#p
        }
    }

    class ItemCore {
        #S;
        #T;
        #U;

        constructor(t, e) {
            this.#S = t, this.#T = e, this.#U = this.#V()
        }

        get rule() {
            return this.#S
        }

        get pos() {
            return this.#T
        }

        get isFinished() {
            return this.pos >= this.rule.rhs.size
        }

        get next() {
            return this.isFinished ? null : this.rule.rhs.get(this.pos)
        }

        get shift() {
            if (this.isFinished) throw RangeError("Something went wrong :(");
            return new ItemCore(this.rule, this.pos + 1)
        }

        #V() {
            let t = `${this.rule.lhs} :=`;
            for (let e = 0; e < this.rule.rhs.size; e++) t += e === this.pos ? " ● " : " ", t += this.rule.rhs.get(e);
            return this.isFinished && (t += " ●"), t
        }

        toString() {
            return this.#U
        }
    }

    class Item {
        #W;
        #X;
        #U;

        constructor(t, e, s) {
            this.#W = new ItemCore(t, e), this.#X = s, this.#U = this.#V()
        }

        get rule() {
            return this.#W.rule
        }

        get pos() {
            return this.#W.pos
        }

        get isFinished() {
            return this.#W.isFinished
        }

        get next() {
            return this.#W.next
        }

        get lookahead() {
            return this.#X
        }

        get shift() {
            if (this.isFinished) throw RangeError("Something went wrong :(");
            return new Item(this.rule, this.pos + 1, this.lookahead)
        }

        get core() {
            return this.#W
        }

        #V() {
            return this.#W.toString() + `	 ${[...this.lookahead].map(t => `${t}`).sort().join(" ")}`
        }

        toString() {
            return this.#U
        }
    }

    class ItemSet extends SSet {
        #U = "";

        constructor(...t) {
            super(t)
        }

        lock() {
            this.#U = `{\n    ${[...this].map(t => t.toString()).sort().join("\n    ")}\n}`
        }

        toString() {
            return this.#U
        }

        copy() {
            return new ItemSet(...this)
        }
    }

    class LRParseTableBuilderBase {
        table;
        grammar;
        configuratingSets;
        states;
        successors;

        constructor(t) {
            this.grammar = t, this.generateConfiguratingSets(), this.generateParsingTable();
            let e = this.table.conflicts;
            console.log(`${e.length} conflicts`, e);
            {
                let s = new Set;
                for (let r of e) if (r.rule && s.add(r.rule), r.rule1 && s.add(r.rule1), r.rule2 && s.add(r.rule2), r.state) for (let i of this.states.get(r.state)) s.add(i.rule);
                s.size && console.log(`Problematic rules:\n    ${[...s].join("\n    ")}`);
                let n = new Set;
                for (let a of e.filter(t => "RR" === t.type)) {
                    let {state: o} = a, l = [a.rule1.toString(), a.rule2.toString()].sort();
                    n.add(`${l[0]}\n    with\n    ${l[1]}\n    on ${this.states.get(o).toString().split("\n").join("\n    ")}\n    `)
                }
                n.size && console.log(`Reduce-reduce conflicts:\n    ${[...n].join("\n    ")}`);
                let h = new Map;
                for (let c of e.filter(t => "SR" === t.type)) {
                    let {state: u, rule: g, symbol: d} = c,
                        p = `${g}\n    on {\n        ${[...this.states.get(u)].map(t => t.core).join("\n        ")}\n    }`;
                    h.has(p) || h.set(p, new Set), h.get(p).add(d)
                }
                h.size && console.log(`Shift-reduce conflicts:\n    ${[...h].map(([t, e]) => t + ` with lookahead ${[...e].join(" ")}`).join("\n\n    ")}`)
            }
        }

        generateParsingTable() {
            for (let [t, e] of (console.log("Generating parsing table entries..."), this.table = new ParsingTable(this.configuratingSets.size), this.configuratingSets.entries())) this.generateActionSetEntries(e, t), this.generateGotoSetEntries(e)
        }

        get startItem() {
            return new Item(this.grammar.startRule, 0, new SymbolSet(this.grammar.follow(JSymbol.__START__)))
        }

        generateConfiguratingSets() {
            console.log("Generating configurating sets..."), this.configuratingSets = new SMap, this.successors = new Map, this.states = new Map;
            let t = this.itemClosure(this.startItem);
            this.configuratingSets.set(t, 0), this.successors.set(0, new Map), this.states.set(0, t);
            let e = new SSet([t]), s = !0;
            for (; s;) {
                s = !1;
                let r = new SSet;
                for (let i of e) {
                    let n = this.configuratingSets.get(i);
                    for (let a of this.grammar.allSymbols) {
                        let o = this.successor(i, a);
                        0 !== o.size && this.addConfiguratingState(n, a, o) && (s = !0, r.add(o))
                    }
                }
                e = r
            }
        }

        addConfiguratingState(t, e, s) {
            if (this.configuratingSets.has(s)) return this.successors.get(t).set(e, this.configuratingSets.get(s)), !1;
            {
                let r = this.configuratingSets.size;
                return this.successors.set(r, new Map), this.configuratingSets.set(s, r), this.states.set(r, s), this.successors.get(t).set(e, r), console.log(`Found ${this.configuratingSets.size}th configurating set (${s.size} items)`), !0
            }
        }

        generateActionSetEntries(t, e) {
            for (let s of e) s.isFinished && s.rule.toString() === this.grammar.startRule.toString() ? this.table.setActionAccept(t, JSymbol.__EOF__) : s.isFinished ? this.generateReductions(t, s) : this.generateShifts(t, s)
        }

        generateReductions(t, e) {
            let s = e.rule;
            for (let r of e.lookahead) this.table.setActionReduce(t, r, s)
        }

        generateShifts(t, e) {
            let s = this.successors.get(t).get(e.next);
            void 0 !== s && this.table.setActionShift(t, e.next, s)
        }

        generateGotoSetEntries(t) {
            for (let e of this.grammar.nonTerminals) {
                let s = this.successors.get(t).get(e);
                void 0 !== s && this.table.setGoto(t, e, s)
            }
        }

        itemClosure(t) {
        }

        closure(t) {
            let e = t.copy();
            for (let s of t) for (let r of this.itemClosure(s)) e.add(r);
            let i = new SMap;
            for (let n of e) for (let a of (i.has(n.core) || i.set(n.core, new SymbolSet), n.lookahead)) i.get(n.core).add(a);
            let o = new ItemSet;
            for (let [l, h] of i) o.add(new Item(l.rule, l.pos, h));
            return o.lock(), o
        }

        successor(t, e) {
            let s = new ItemSet;
            for (let r of t) r.isFinished || r.next !== e || s.add(r.shift);
            return this.closure(s)
        }
    }

    class LR1ParseTableBuilder extends LRParseTableBuilderBase {
        memoization = new SMap;

        constructor(t) {
            super(t)
        }

        itemClosure(t) {
            {
                this.memoization || (this.memoization = new SMap);
                let e = this.memoization.get(t);
                if (null != e) return e
            }
            let s = new ItemSet(t);
            if (t.isFinished) return s;
            let r = s.copy(), i = !0;
            for (; i;) {
                i = !1;
                let n = new ItemSet;
                for (let a of r) {
                    if (a.isFinished) continue;
                    let o = a.next;
                    if (!this.grammar.nonTerminals.has(o)) continue;
                    let l = a.rule.rhs.substring(a.pos + 1), h = new SymbolSet(this.grammar.first(l));
                    if (h.has(JSymbol.__EPSILON__)) for (let c of (h.delete(JSymbol.__EPSILON__), a.lookahead)) h.add(c);
                    for (let u of this.grammar.getRules(o)) {
                        let g = new Item(u, 0, h);
                        i ||= !s.has(g), s.add(g), n.add(g)
                    }
                }
                r = n
            }
            return s.lock(), this.memoization.set(t, s), s
        }
    }

    class SymbolSet extends Set {
        dirty = !0;
        #U = "";

        constructor(t = null) {
            super(t)
        }

        #Y() {
            this.#U = [...this].map(t => t.id).toSorted().join(" ")
        }

        add(t) {
            return this.dirty ||= this.has(t), super.add(t)
        }

        delete(t) {
            return this.dirty ||= super.delete(t)
        }

        clear() {
            this.dirty ||= this.size > 0, super.clear()
        }

        toString() {
            return this.dirty && (this.#Y(), this.dirty = !1), this.#U
        }
    }

    class Rule {
        #Z;
        #$;
        #_;
        #aa;
        #ab;

        constructor(t, e, s, r) {
            this.#_ = t, this.#aa = e, this.#ab = 0 === e.size, this.#$ = s, this.#Z = r
        }

        get lhs() {
            return this.#_
        }

        get rhs() {
            return this.#aa
        }

        get unwrap() {
            return this.#Z
        }

        get chained() {
            return this.#$
        }

        get empty() {
            return this.#ab
        }

        toString() {
            return `${this.unwrap ? "" : "__WRAP__ "}${this.chained ? "__CHAIN__ " : ""}${this.lhs} := ${this.rhs}`
        }
    }

    class SymbolString {
        #ac;
        #ad;

        constructor(...t) {
            this.#ac = t, this.#ad = t.join(" ")
        }

        get(t) {
            return this.#ac[t]
        }

        get firstTkn() {
            return this.#ac[0] ?? null
        }

        get lastTkn() {
            return this.#ac[this.#ac.length - 1] ?? null
        }

        get size() {
            return this.#ac.length
        }

        get symbols() {
            return this.#ac
        }

        toString() {
            return this.#ad
        }

        substring(t, e = -1) {
            return e < 0 && (e += this.size + 1), new SymbolString(...[...this.symbols].splice(t, e - t))
        }

        [Symbol.iterator]() {
            return this.symbols[Symbol.iterator]()
        }

        concat(t) {
            return new SymbolString(...this, t)
        }

        forEach(t) {
            this.symbols.forEach(t)
        }
    }


    function createLexerFromFile(file_contents) {
        const ignored = [];
        const lex_rules = file_contents
            .trim()
            .split(/\s*\n\s*/g)
            .filter(i => !i.startsWith('//'))
            .map(i => i.split(/\s+:=\s+/))
            .map(([a, b]) => {
                if(a.startsWith('__IGNORED__ ')) {
                    a = a.replace('__IGNORED__', '').trim();
                    ignored.push(a);
                }

                b ??= a.replaceAll(/[()[+*?.\]|\\]/g, '\\$&');

                return ({
                    nfa: Regex.parse(b).compile(),
                    symbol: JSymbol.get(a)
                });
            });

        const dfa = compileToDFA(...lex_rules);

        return new Lexer(dfa, ignored.map(i => JSymbol.get(i)));
    }

    function createParserFromFile(t, ...e) {
        let s = [].concat(...e.map(t => t.trim().split(/\s*\n\s*/g).filter(t => !t.startsWith("//")))),
            r = s.map(t => t.split(/\s+/)).map(t => {
                let e = !0, s = !1, r, i = t.shift();
                for (; ;) {
                    if ("__WRAP__" === i) e = !1; else if ("__CHAIN__" === i) s = !0; else break;
                    i = t.shift()
                }
                if (r = JSymbol.get(i), "__EPSILON__" === t.shift()) return new Rule(r, new SymbolString, !1, !0);
                let n = t.map(t => JSymbol.get(t));
                return new Rule(r, new SymbolString(...n), s, e)
            }), i = new Grammar(r, t), n = new LR1ParseTableBuilder(i), a = n.table;
        return new LRParser(a)
    }

    async function fetchTextContents(t) {
        return (await fetch(t)).text()
    }

    return {
        Lexer,
        LRParser,
        Token,
        JSymbol,
        ParsingTable,
        LR1ParseTableBuilder,
        fetchTextContents,
        createLexerFromFile,
        createParserFromFile
    }
})();
